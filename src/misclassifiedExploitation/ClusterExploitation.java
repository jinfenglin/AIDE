package misclassifiedExploitation;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;

import mainPackage.Tuple;

import configuration.DBConnection;
import configuration.Global;



public class ClusterExploitation extends MisclassifiedExploitation{


	/** This method implements the clustering-based misclassified sample exploitation technique.
	 * In this method we sample around each of the clusters by creating queries such as the following:
	 * SELECT rowc, colc FROM testing WHERE (rowc >= 662.5 AND rowc <= 702.5 AND  colc >= 992 AND colc <= 1053 )
	 * 
	 * @param numberOfClusters the number of clusters to be explored.
	 * @return an arrayList containing the samples that we have selected from the misclassified sampling areas
	 * @throws Exception
	 */
	@Override
	public ArrayList<Tuple> getNearestMissclassified(int numberOfClusters, ArrayList<Tuple> misclassified) throws Exception{
		Statement statement;
		ResultSet rs;
		ArrayList<Tuple> rand = new ArrayList<Tuple>();

		double percenAroundMiscl = Global.PERCENT_AROUND_MISCLASSIFIED;

		KMeans k = new KMeans();
		ArrayList<Tuple> centroids = k.getCentroids(numberOfClusters);
		int[] assignments = null;
		if(k.centroidsExist == true){
			assignments = k.assignments;
		}
		System.out.println("Exploring the clusters of misclassified. Number of clusters: "+numberOfClusters);
		//total number of tuples we should spend on the misclassified phase.
		for(int im=0; im<centroids.size(); im++){
			//System.out.println("This is the centroid: "+centroids.get(0));
			ArrayList<Tuple> h = new ArrayList<Tuple>();
			Tuple t = centroids.get(im);
			String query = "SELECT "+Global.OBJECT_KEY+" , ";
			for(int i=0; i<Global.attributes.size(); i++){
				if(i!=Global.attributes.size()-1)
					query += Global.attributes.get(i).getName()+" , ";
				else
					query += Global.attributes.get(i).getName();
			}
			query += " FROM "+Global.TABLE_NAME+ " WHERE ";
			for(int i = 0; i<Global.attributes.size(); i++){
				ArrayList<String> valuesForQuery = getClosest(Global.attributes.get(i).getDomain(), percenAroundMiscl, (double)t.valueAt(i));
				if(k.centroidsExist == true){
					while(checkOK(misclassified, valuesForQuery, assignments, im, i) == false){
						percenAroundMiscl++;
						valuesForQuery = getClosest(Global.attributes.get(i).getDomain(), percenAroundMiscl, (double)t.valueAt(i));
					}
				}
				query += " ("+Global.attributes.get(i).getName()+ " >= "+valuesForQuery.get(0)+ " AND "+Global.attributes.get(i).getName()+ " <= "+valuesForQuery.get(1)+") ";
				if(i< Global.attributes.size()-1){
					query += " AND ";
				}
			}
			query += " ORDER BY RANDOM() LIMIT "+Global.RANDOM_AROUND_MISCLASSIFIED;
			Connection connection = DBConnection.getConnection();
			statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
			rs = statement.executeQuery(query);
			while(rs.next()){
				Object key = rs.getString(1);
				Object[] attrValues = new Object[Global.attributes.size()];
				for(int m=1; m<=Global.attributes.size(); m++){
					attrValues[m-1] = rs.getString(m+1); 
				}
				Tuple tuple = new Tuple(key, attrValues);
				h.add(tuple);
			}
			rand.addAll(h);
		}
		return rand; //returns an ArrayList with the k nearest neighbors
	}

	private boolean checkOK(ArrayList<Tuple> miscl, ArrayList<String> v, int[] assignments, int centroidIndex, int attribute) throws NumberFormatException, IOException {
		boolean flag = true; 
		ArrayList<Tuple> m = new ArrayList<Tuple>(); //the misclassified who belong to this centroid
		for(int i=0; i<assignments.length; i++){
			if(assignments[i] == centroidIndex){
				m.add(miscl.get(i));
			}
		}
		for(int i=0; i<m.size(); i++){
			Tuple tuple = m.get(i);
			if((double)(tuple.valueAt(attribute))<=Double.parseDouble(v.get(0))
					||  (double)(tuple.valueAt(attribute))>=Double.parseDouble(v.get(1))){
				flag = false;
				break;
			}
		}
		return flag;
	}

	private ArrayList<String> getClosest(ArrayList<Object> values, double number, double value) throws IOException{
		ArrayList<String> toReturn = new ArrayList<String>();
		double min = Double.parseDouble(""+values.get(0));
		double max = Double.parseDouble(""+values.get(values.size()-1));
		double perce = (max-min)/(100/number);
		double downLimit = value - perce;
		double upLimit = value + perce;
		toReturn.add(""+downLimit);
		toReturn.add(""+upLimit);
		return toReturn;
	}

}
