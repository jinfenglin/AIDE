package misclassifiedExploitation;

import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;

import configuration.DBConnection;
import configuration.Global;

import mainPackage.Tuple;

public class ExploitEachMisclassified extends MisclassifiedExploitation{

	/** This method implements the NON-clustering-based misclassified sample exploitation technique.
	 * In this method we sample around each misclassified sample by creating queries such as the following:
	 * SELECT rowc, colc FROM testing WHERE (rowc >= 662.5 AND rowc <= 702.5 AND  colc >= 992 AND colc <= 1053 )
	 * 
	 * @param numberOfClusters is an unused variable in this case.
	 * @return an arrayList containing the samples that we have selected from the misclassified sampling areas
	 * @throws Exception
	 */
	@Override
	public ArrayList<Tuple> getNearestMissclassified(int numberOfClusters, ArrayList<Tuple> misclassified) throws Exception {
		Statement statement;
		ResultSet rs;
		ArrayList<Tuple> rand = new ArrayList<Tuple>();

		double percenAroundMiscl = Global.PERCENT_AROUND_MISCLASSIFIED;
		
		for(int im=0; im<misclassified.size(); im++){
			//System.out.println("This is the centroid: "+centroids.get(0));
			ArrayList<Tuple> h = new ArrayList<Tuple>();
			Tuple t = misclassified.get(im);
			String query = "SELECT "+Global.OBJECT_KEY+" , ";
			for(int i=0; i<Global.attributes.size(); i++){
				if(i!=Global.attributes.size()-1)
					query += Global.attributes.get(i).getName()+" , ";
				else
					query += Global.attributes.get(i).getName();
			}
			query += " FROM "+Global.TABLE_NAME+ " WHERE ";
			for(int i = 0; i<Global.attributes.size(); i++){
				ArrayList<String> valuesForQuery = getClosest(Global.attributes.get(i).getDomain(), percenAroundMiscl, (double)t.valueAt(i));
				query += " ("+Global.attributes.get(i).getName()+ " >= "+valuesForQuery.get(0)+ " AND "+Global.attributes.get(i).getName()+ " <= "+valuesForQuery.get(1)+") ";
				if(i< Global.attributes.size()-1){
					query += " AND ";
				}
			}
			query += " ORDER BY RANDOM() LIMIT "+Global.RANDOM_AROUND_MISCLASSIFIED;
			Connection connection = DBConnection.getConnection();
			statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
			rs = statement.executeQuery(query);
			while(rs.next()){
				Object key = rs.getString(1);
				Object[] attrValues = new Object[Global.attributes.size()];
				for(int m=1; m<=Global.attributes.size(); m++){
					attrValues[m-1] = rs.getString(m+1); 
				}
				Tuple tuple = new Tuple(key, attrValues);
				h.add(tuple);
			}

			rand.addAll(h);
		}
		return rand; //returns an ArrayList with the k nearest neighbors
	}
	
	private ArrayList<String> getClosest(ArrayList<Object> values, double number, double value) throws IOException{
		ArrayList<String> toReturn = new ArrayList<String>();
		double min = Double.parseDouble(""+values.get(0));
		double max = Double.parseDouble(""+values.get(values.size()-1));
		double perce = (max-min)/(100/number);
		double downLimit = value - perce;
		double upLimit = value + perce;
		toReturn.add(""+downLimit);
		toReturn.add(""+upLimit);
		return toReturn;
	}

}
