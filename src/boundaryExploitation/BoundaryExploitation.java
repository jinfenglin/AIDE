package boundaryExploitation;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

import mainPackage.Attribute;
import mainPackage.DTUserModel;
import mainPackage.Tuple;

import configuration.DBConnection;
import configuration.Global;


public class BoundaryExploitation {
	//keeps an arraylist of boundaries (as double) for each attribute.
	private HashMap<Attribute, ArrayList<Double>> allBounds;

	/**Constructs a new BoundaryExploitation object and initializes the
	 * hash map that will keep all the boundaries explored in previous
	 * iterations for each attribute.
	 * 
	 * @throws IOException
	 */
	public BoundaryExploitation() throws IOException{ 
		allBounds = new HashMap<Attribute, ArrayList<Double>>();
		for(int i=0; i<Global.attributes.size(); i++){
			ArrayList<Double> boundsForAttr = new ArrayList<Double>();
			allBounds.put(Global.attributes.get(i), boundsForAttr);
		}
		
	}

	/**The main exploitation function that constructs a sampling query with 
	 * the appropriate ranges around each boundary, 
	 * sends the query to the database and returns the random samples around the boundaries.
	 * @return ArrayList<Tuple> 
	 * 
	 * @throws SQLException
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public ArrayList<Tuple> exploitBoundaries() throws SQLException, IOException, InterruptedException{
		String query = "SELECT "+Global.OBJECT_KEY+" , ";
		for(int j=0; j<Global.attributes.size(); j++){		
			if(j==Global.attributes.size()-1)
				query += ""+Global.attributes.get(j).getName()+" ";
			else
				query += ""+Global.attributes.get(j).getName()+" , ";
		}
		query+= " FROM "+Global.TABLE_NAME+ " WHERE ";
		
		ArrayList<Tuple> samples = new ArrayList<Tuple>(); 
		FindBoundaries f = new FindBoundaries();
		//f.getBoundaries returns boundaries in this format: 'rowc >= 100' , 'colc < 99' etc.
		ArrayList<String> bounds = f.getBoundaries(DTUserModel.getTree().toString());
		String queryPart = "";
		for(int j=0; j<Global.attributes.size(); j++){
			ArrayList<String> a = new ArrayList<String>();
			for(int i=0; i<bounds.size(); i++){
				String bound = bounds.get(i);
				Scanner scanner = new Scanner(bound); 
				scanner.useDelimiter(" +"); 
				String attr = scanner.next(); //get the attribute this boundary refers to
				scanner.next(); 
				String value = scanner.next(); //get the value of the boundary 
				if(Global.attributes.get(j).getName().equalsIgnoreCase(attr)){
					a.addAll(getClosest(Global.attributes.get(j).getDomain(), Global.PERCENT_AROUND_BOUNDARY, Double.parseDouble(value)));
				}
			}
			String fy = addToQuery(Global.attributes.get(j), a);
			if(!fy.equals("") && j!=0 && !queryPart.endsWith(" WHERE ")){
				queryPart += " OR ";
			}
			queryPart += fy;
		}
		query += queryPart;
		int totalTuples = 0;			
		if(Global.ADAPTIVE_BOUNDARY){			
			totalTuples = findTotalTuples(bounds);			
		}else{			
			totalTuples = Global.RANDOM_AROUND_BOUNDARIES;			
		}
		query += " ORDER BY RANDOM() LIMIT "+totalTuples;
		
		if(query.contains(" WHERE OR ") || query.contains("WHERE  OR")){ //if the query we built contains one of this "wrong" SQL expressions
			query = query.replaceAll("WHERE *OR", "WHERE"); //fix the expression
		}
		samples.addAll(runQuery(query));	// Does that add all samples???????????????????????????

		updateBoundaries(bounds);
		return samples;
	}

	/**Sends the query to the database and returns an arraylist with the tuples
	 * that the query returned.
	 * 
	 * @param query  the query to send to the db
	 */
	private ArrayList<Tuple> runQuery(String query) throws SQLException, IOException {
		System.out.println("Query for boundaries: "+query);
		ArrayList<Tuple> toReturn = new ArrayList<Tuple>();
		Connection connection = DBConnection.getConnection();
		Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
		ResultSet rs = statement.executeQuery(query);
		while(rs.next()){
			Object key = rs.getString(1);
			Object[] attrValues = new Object[Global.attributes.size()];
			for(int m=1; m<=Global.attributes.size(); m++){
				attrValues[m-1] = rs.getString(m+1); 
			}
			Tuple tuple = new Tuple(key, attrValues);
			toReturn.add(tuple);
		}
		return toReturn;
	}

	/**This method adds the correct ranges to the query.
	 * @param attr		the attr around which we will fetch tuples
	 * @param newAreas			an arraylist that contains the new ranges to be added to the query
	 * @return					part of the query in String format.
	 * @throws IOException 
	 * @throws SQLException 
	 */
	private String addToQuery(Attribute attr, ArrayList<String> newAreas) throws IOException, SQLException{
		//find how many tuples you should fetch for this boundary
		
		String query = "";
		//keep building the query
		for(int i=0; i<newAreas.size()/2; i++){
			if(i!=0){
				query += " OR ";
			}
			query += " ("+attr.getName()+ " >= "+newAreas.get(i*2)+ " AND "+attr.getName()+ " <= "+newAreas.get((i*2)+1)+") ";
		}
		return query;
	}
	
	private int findTotalTuples(ArrayList<String> bounds) throws IOException{
		int totalTuples = 0; 
		for(int i=0; i<bounds.size(); i++){
			int num = numberOfTuples(bounds.get(i), bounds.size());
			//System.out.println("For this boundary: "+bounds.get(i)+" that much tuples: "+num);
			totalTuples += num;
		}
		return (int)totalTuples/2;
	}

	private int numberOfTuples(String bound, int numberOfBoundaries) throws IOException{
		double change = percentageOfChange(bound);
		//System.out.println("This is the percentage of change: "+change);
		int toSaveTuples = 0;
		if(change==100){
			return (int)((Global.EXPLOIT_SAMPLES/numberOfBoundaries)+Global.EXPLOIT_ERROR+toSaveTuples);
		}
		double tuples = change*(Global.EXPLOIT_SAMPLES/numberOfBoundaries)+Global.EXPLOIT_ERROR+toSaveTuples;
		//System.out.println("Number of tuples for this boundary = "+tuples);
		if(tuples>((Global.EXPLOIT_SAMPLES/numberOfBoundaries)+Global.EXPLOIT_ERROR+toSaveTuples)){
			return (int)((Global.EXPLOIT_SAMPLES/numberOfBoundaries)+Global.EXPLOIT_ERROR+toSaveTuples);
		}
		return (int)tuples;
	}

	private void updateBoundaries(ArrayList<String> bounds) throws IOException{
		for(int i=0; i<bounds.size(); i++){
			Scanner s = new Scanner(bounds.get(i)); 
			s.useDelimiter(" +");
			String attr = s.next(); s.next(); Double value = Double.parseDouble(s.next());
			for(int j=0; j<Global.attributes.size(); j++){
				if(Global.attributes.get(j).getName().equals(attr))
					allBounds.get(Global.attributes.get(j)).add(value);
			}
		}
	}

	private double percentageOfChange(String bound) throws IOException{
		double change = 0;
		Attribute attr = null;

		Scanner s = new Scanner(bound); //the boundary in this format: "rowc >= 34"
		s.useDelimiter(" +");
		String attr1 = s.next(); s.next(); String value = s.next();
		double boundary = Double.parseDouble(value);
		for(int i=0; i<Global.attributes.size(); i++){
			if(Global.attributes.get(i).getName().equals(attr1))
				attr = Global.attributes.get(i);
		}

		ArrayList<Double> boundaries = allBounds.get(attr);
	
		if(boundaries.size()!=0){//how to find the percentage of change. //find the closest value to what you are examining
			//if the percentage of change for that value is above a limit then show all of the tuples for that boundary (so percentage of change 100)
			double previousBound = boundaries.get(0);
			for(int i=0; i<boundaries.size(); i++){ //find what was the previous boundary
				if(Math.abs(boundaries.get(i)-boundary)<=Math.abs(previousBound-boundary)){
					previousBound = boundaries.get(i);
				}
			}
			if(previousBound == boundary){
				change = 0;
			}else{ //find the percentage of change from previous iteration of this specific boundary
				double min = Double.parseDouble(""+attr.getDomain().get(0));
				double max = Double.parseDouble(""+attr.getDomain().get(attr.getDomain().size()-1));
				double normPreviousBoundary = ((previousBound - min)/(max-min))*100;
				double normBoundary = ((boundary - min)/(max-min))*100;
				change = Math.abs(normPreviousBoundary - normBoundary)/100;
			}
		}else{
			change = 100;
		}
		return change;
	}
	
	public ArrayList<String> getClosest(ArrayList<Object> values, double number, double value) throws IOException{
		ArrayList<String> toReturn = new ArrayList<String>();
		double min = Double.parseDouble(""+values.get(0));
		double max = Double.parseDouble(""+values.get(values.size()-1));
		double perce = (max-min)/(100/number);
		double downLimit = value - perce;
		double upLimit = value + perce;
		toReturn.add(""+downLimit);
		toReturn.add(""+upLimit);
		return toReturn;
	}

}
